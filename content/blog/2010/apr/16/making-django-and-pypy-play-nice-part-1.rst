
Making Django and PyPy Play Nice (Part 1) 
==========================================


If you track Django's commits aggressivly (ok so just me...), you may have noticed that there have been a number of commits to improve the compatibility of Django and PyPy in the last couple of days.  In the run up to Django 1.0 there were a ton of commits to make sure Django didn't have too many assumptions that it was running on CPython, and that it could work with systems like Jython and PyPy.  Unfortunately, since then, our support has laxed a little, and a number of tests have begun to fail.  In the past couple of days I've been working to correct this.  Here are some of the things that were wrong

The first issue I ran into was, in various tests, ``response.context`` and ``response.template`` being ``None``, instead of the ``lists`` that were expected.  This was a pain to diagnose, but the ultimate source of the bug is that Django registers a signal handler in the test client that listens for templates being rendered.  However, it doesn't actually unregister that signal receiver.  Instead it relies on the fact that signals are stored as ``weakrefs``, and when the function ends, the receivers that were registered (which were local variables) would be automatically deallocated.  On PyPy, Jython, and any other system with a garbage collector more advanced than CPython's reference counting, the local variables aren't guaranteed to be deallocated at the end of the function, and therefore the ``weakref`` can still be alive.  Truthfully, I'm not 100% sure how this results in the next signal being sent not to store the appropriate data, but it does.  The solution is the make sure that the signals are manually disconnected at the end of the run.  This was fixed in `r12964 of Django <http://code.djangoproject.com/changeset/12964>`_.

The next issue was actually a problem in PyPy, specifically it was crashing with a ``UnicodeDecodeError``.  When I say crashing I mean crashing in the C sense of the word, not the Python, nice exception and stack trace sense... sort of.  PyPy is written in a language named RPython, RPython is Pythonesque (all valid RPython is valid Python), and has exceptions.  However if they aren't caught they sort of propagate to the top, they give you a kind-of-ok stacktrace, but its function names are all the generated function names from the C source, not useful ones from the RPython source.  Internally, PyPy uses an ``OperationError`` to keep track of exceptions at the interpreter level.  A trick to debugging RPython is, if running the code on top of CPython works, than running it translated to C will work, and the contrapositive appears true as well, if the C doesn't work, running on CPython won't work.  After trying to run the code on CPython, the location of the exception bubbled right to the top, and the `fix followed easily <https://codespeak.net/viewvc/?view=rev&revision=73755>`_.

These are the first two issues I fixed, a couple others have been fixed and committed, and a further few have also been fixed, but not committed yet.  I'll be writing about those as I find the time.
